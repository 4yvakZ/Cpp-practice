# Lab2 Динамический массив
## Задание
В вашу задачу входит реализация АТД динамического массива:
```
template<typename T> class Array final
```
должен поддерживать следующие операции:
```
Array();
Array(int capacity);
```
Конструктор распределяет память, необходимую для хранения некоторого количества элементов. 
Конструктор без параметров использует значение емкости по умолчанию (например, 8 или 16), конструктор с параметром capacity – явно переданное значение.
```
~Array();
```
Деструктор освобождает память, выделенную под хранение элементов. 
При необходимости, при освобождении памяти вызываются деструкторы хранимых элементов.
```
int insert(const T& value);
int insert(int index, const T& value);
```
Вставляет переданное значение в конец массива, или в указанную позицию, увеличивая размер массива на 1 и, при необходимости, сдвигая существующие элементы вправо. 
Возвращает индекс, в который был вставлен элемент. Если памяти для добавления элемента недостаточно, то перераспределяет память, копируя уже существующие элементы в новую область. 
Затем старый блок освобождается. Для копирования и сдвигания элементов необходимо использовать move-семантику. 
(Если тип `T` ее поддерживает. В противном случае необходимо использовать копирование с последующим вызовом деструктора). 
Выделение памяти происходит каждый раз с увеличением в 1.6..2 раза относительно текущего размера.
```
void remove(int index);
```
Удаляет элемент из указанной позиции массива, сдвигая остальные элементы влево (сдвиги выполняются аналогично `insert()`,но память при этом не освобождается).
```
const T& operator[](int index) const; T& operator[](int index);
```
Оператор индексирования позволяет обратиться к элементу массива по индексу для чтения и для записи.
```
int size() const;
```
Возвращает текущий размер (количество реально существующих в массиве) элементов.
```
Iterator iterator(); ConstIterator iterator() const;
```
Возвращает итератор, указывающий на первый элемент массива. При помощи такого итератора массив можно обойти в прямом порядке: от первого элемента до последнего.
```
Iterator reverseIterator(); ConstIterator reverseIterator() const;
```
Возвращает итератор, указывающий на последний элемент массива. При помощи такого итератора массив можно обойти в обратном порядке: от последнего элемента к первому.

Функции работы с индексом не должны выполнять проверку границ. Но в отладочной версии такие проверки можно добавить используя механизм утверждений.

Управление памятью должно быть реализовано через функции `malloc()` и `free()`.

Итератор должен быть реализован как внутренний для `Array<T>` класс, и предоставлять следующий интерфейс:
```
const T& get() const;
```
Получает значение массива в текущей позиции итератора.
```
void set(const T& value);
```
Устанавливает значение в текущей позиции итератора.
```
void next();
```
Перемещает текущую позицию итератора на следующий элемент.
```
bool hasNext() const;
```
Возвращает `true`, если итератор может перейти к следующему элементу, или `false` в противном случае.

Пример использования: поместим в массив числа от 1 до 10, умножим каждое на 2, затем выведем их на экран.
```
Array<int> a;
for (int i = 0; i < 10; ++i)
a.insert(i + 1);

for (int i = 0; i < a.size(); ++i)
a[i] \*= 2;

for (auto it = a.iterator(); it.hasNext(); it.next())
std::cout << it.get() << std::endl;
```
Для разработанных классов реализовать модульные тесты на базе Google Test или CppUnit.
## Тесты
```
TEST_METHOD(simpleInt)
{
	Array<int> a;
	Assert::AreEqual(0, a.size());
	for (int i = 0; i < 10; ++i) {
		a.insert(i + 1);
	}
	Assert::AreEqual(10, a.size());
	for (int i = 0; i < a.size(); ++i) {
		a[i] *= 2;
		Assert::AreEqual((i + 1) * 2, a[i]);
	}
}

TEST_METHOD(string) {
	Array<std::string> a;
	for (int i = 0; i < 10; i++) {
		Assert::AreEqual(i, a.insert("kek"));
	}
	Assert::AreEqual(10, a.size());
	a.remove(0);
	a.remove(0);
	Assert::AreEqual(8, a.size());    
	for (auto it = a.iterator(); it.hasNext(); it.next())
		std::cout << it.get() << std::endl;
}

TEST_METHOD(emptyArray) {
	Array<int> a;
	for (int i = 0; i < 10; i++) {
		Assert::AreEqual(i, a.insert(i+1));
	}
	Assert::AreEqual(10, a.size());
	for (int i = 0; i < 10; i++) {
		a.remove(1);
	}
	Assert::AreEqual(1, a.size());
	for (int i = 0; i < 10; i++) {
		a.remove(0);
	}
	Assert::AreEqual(0, a.size());
}
		
TEST_METHOD(outOfBounds) {
	Array<int> a;
	for (int i = 0; i < 10; i++) {
		Assert::AreEqual(i, a.insert(i + 1));
	}
	Assert::AreEqual(10, a.size());
	Assert::AreEqual(-1, a.insert(100, 1));
	Assert::AreEqual(10, a.size());
	a[-1];
}
```
## Результаты
Был реализован класс динамического массива и написаны тесты, для проверки работы не только со стандартными типами, но и с объектами классов (например, `string`).
