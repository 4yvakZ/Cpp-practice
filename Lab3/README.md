# Lab3 Алгоритм сортировки
## Задание 
В вашу задачу входит разработка обобщенной функции `sort()`, реализующей алгоритм быстрой сортировки со следующими оптимизациями:

- Выбор опорного элемента, как медианы из первого, среднего и последнего элемента сортируемого интервала;
- Исключение хвостовой рекурсии: функция должна определять длины получившихся интервалов после разбиения и рекурсивно сортировать интервал меньшей длины, итеративно обрабатывая интервал большей длины;
- Использование алгоритма сортировки вставками для коротких интервалов (длину такого интервала необходимо подобрать экспериментально).
- Использовать move-семантику для обмена элементов в процессе разбиения и при сортировке вставками.

Функция должна принимать три аргумента: начало `first` и конец `last` сортируемого интервала и предикат сортировки comp,который принимает два аргумента – элементы массива `a` и `b`, и возвращает true, если `a < b`, то есть в отсортированном массиве элемент `a` должен располагаться *перед* `b`.
```
template<typename T, typename Compare>
void sort(T \*first, T \*last, Compare comp)
```
где предикат упорядочивания должен удовлетворять прототипу 
```
template<typename T>
bool comp(const T &a, const T &b)
```
Сортировка массива из 100 целых чисел при помощи разработанной функции будет выглядеть следующим образом:
```
int a[100];
sort(a, a + 100, [](int a, int b) { return a < b; });
```
Для разработанной функции необходимо создать набор модульных тестов (например, Google Test или CppUnit). Тесты должны быть репрезентативными, покрывать общий и максимальное количество граничных случаев. Тесты должны покрывать случаи сортировки массивов из элементов как примитивных, так и нетривиальных типов.

## Тесты
```
TEST_METHOD(quickSortTest)
{
	constexpr int n = 10;
	int a[n];
	for (int i = 0; i < n; i++) {
		a[i] = n - i;
	}
	insertionSort(a, a + n, [](int a, int b) { return a < b; });
	for (int i = 0; i < n; i++) {
		Assert::AreEqual(i + 1, a[i]);
	}
}

TEST_METHOD(quickSortTestOneElem)
{
	constexpr int n = 1;
	int a[n];
	for (int i = 0; i < n; i++) {
		a[i] = n - i;
	}
	insertionSort(a, a + n, [](int a, int b) { return a < b; });
	for (int i = 0; i < n; i++) {
		Assert::AreEqual(i + 1, a[i]);
	}
}
TEST_METHOD(insertionSortTest)
{
	constexpr int n = 10;
	int a[n];
	for (int i = 0; i < n; i++) {
		a[i] = n - i;
	}
	insertionSort(a, a + n, [](int a, int b) { return a < b; });
	for (int i = 0; i < n; i++) {
		Assert::AreEqual(i + 1, a[i]);
	}
}

TEST_METHOD(insertionSortTestOneElem)
{
	constexpr int n = 1;
	int a[n];
	for (int i = 0; i < n; i++) {
		a[i] = n - i;
	}
	insertionSort(a, a + n, [](int a, int b) { return a < b; });
	for (int i = 0; i < n; i++) {
		Assert::AreEqual(i + 1, a[i]);
	}
}
TEST_METHOD(sortTest)
{
	constexpr int n = 10;
	int a[n];
	for (int i = 0; i < n; i++) {
		a[i] = n - i;
	}
	sort(a, a + n, [](int a, int b) { return a < b; }, 5);
	for (int i = 0; i < n; i++) {
		Assert::AreEqual(i + 1, a[i]);
	}
}

TEST_METHOD(sortTestOneElem)
{
	constexpr int n = 1;
	int a[n];
	for (int i = 0; i < n; i++) {
		a[i] = n - i;
	}
	sort(a, a + n, [](int a, int b) { return a < b; }, 3);
	for (int i = 0; i < n; i++) {
		Assert::AreEqual(i + 1, a[i]);
	}
}
```
## Выводы
Были реализованны три алгоритма сортировки: сортировка вставками, quicksort и quicksort с переходом на сортировку вставками при малых размерах масссива.
Подбор критического размера массива, при котором происходит переход на сортировку вставками, происходил на обратно отсортированном массиве.
При этом было замечено улучшение при размерах от 0 до 4, однако дальше значения времени выполнения не менялись в предалах погрешности. 
Предполагаю, что Ryzen 9 5900 слишком мощный для данной задачи)